"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const utils_1 = require("../utils");
const ruleByElement = {
    img(context, node) {
        const altAttribute = utils_1.getElementAttribute(node, "alt");
        if (!altAttribute) {
            if (utils_1.isPresentationRole(node)) {
                context.report({ node: node, messageId: "imgPresentation" });
            }
            else {
                context.report({ node: node, messageId: "imgMissingAlt" });
            }
        }
        else {
            const altValue = utils_1.getAttributeValue(altAttribute);
            if (!altValue && altValue !== "") {
                context.report({ node: node, messageId: "imgInvalidAlt" });
            }
        }
    },
    object(context, node) {
        if (!utils_1.hasAriaLabel(node) &&
            !utils_1.getElementAttributeValue(node, "title") &&
            !utils_1.hasAccessibleChild(node)) {
            context.report({ node: node, messageId: "object" });
        }
    },
    area(context, node) {
        if (!utils_1.hasAriaLabel(node) && !utils_1.getElementAttributeValue(node, "alt")) {
            context.report({ node: node, messageId: "area" });
        }
    },
    'input[type="image"]'(context, node) {
        if (utils_1.getElementAttributeValue(node, "type") === "image" &&
            !utils_1.hasAriaLabel(node) &&
            !utils_1.getElementAttributeValue(node, "alt")) {
            context.report({ node: node, messageId: "input" });
        }
    }
};
const rule = {
    meta: {
        docs: {
            url: utils_1.makeDocsURL("alt-text")
        },
        messages: {
            area: "Each area of an image map must have a text alternative through the `alt`, `aria-label`, or `aria-labelledby` prop.",
            imgMissingAlt: "img elements must have an alt prop, either with meaningful text, or an empty string for decorative images.",
            imgInvalidAlt: `Invalid alt value for img. Use alt="" for presentational images.`,
            imgPresentation: `Prefer alt="" over a presentational role. First rule of aria is to not use aria if it can be achieved via native HTML.`,
            input: `<input> elements with type="image" must have a text alternative through the alt, aria-label, or aria-labelledby prop.`,
            object: "Embedded <object> elements must have alternative text by providing inner text, aria-label or aria-labelledby props."
        },
        schema: [
            {
                type: "object",
                properties: ["elements", ...Object.keys(ruleByElement)].reduce((accum, key) => Object.assign(accum, {
                    [key]: {
                        type: "array",
                        items: {
                            type: "string"
                        },
                        uniqueItems: true
                    }
                }), {})
            }
        ]
    },
    create(context) {
        const options = context.options[0] || {};
        const elements = options.elements || Object.keys(ruleByElement);
        const elementTypes = new Set(elements.reduce((accum, element) => [
            ...accum,
            element === 'input[type="image"]' ? "input" : element,
            ...(options[element] || [])
        ], []));
        return utils_1.defineTemplateBodyVisitor(context, {
            VElement(node) {
                let elementType = utils_1.getElementType(node);
                if (!elementTypes.has(elementType)) {
                    return;
                }
                if (elementType === "input") {
                    elementType = 'input[type="image"]';
                }
                if (!elements.includes(elementType)) {
                    elementType = elements.find((element) => (options[element] || []).includes(elementType));
                }
                elementType && ruleByElement[elementType](context, node);
            }
        });
    }
};
exports.default = rule;
